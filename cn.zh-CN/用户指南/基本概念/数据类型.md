# 数据类型 {#concept_jhp_4bb_5db .concept}

本文向您介绍MaxCompute2.0支持的数据类型，包括基本数据类型和复杂类型。

## 基本数据类型 {#section_b53_rbb_5db .section}

MaxCompute2.0支持的基本数据类型如下表所示，新增类型有TINYINT、SMALLINT、 INT、 FLOAT、VARCHAR、TIMESTAMP和BINARY，MaxCompute表中的列必须是下列描述的任意一种类型，详情如下：

**说明：** 

目前MaxCompute SQL及新版本Mapreduce支持的Set命令分为以下两种方式：

-   session级别：要使用新数据类型（Tinyint、Smallint、Int、Float、Varchar、TIMESTAMP BINARY），需在建表语句前加上set语句`set odps.sql.type.system.odps2=true;`，并与建表语句一起提交执行。通过MaxCompute Studio提交的sql工具默认自动加上该set语句提交执行。
-   project级别：支持对需要使用新数据类型（包括建表、查表或其他操作）的项目进行项目级别的新类型开启。即当您需要在某个项目使用SQL语句，project的Owner就可根据需要对这个project进行设置。命令如下：

    ```
    - setproject odps.sql.type.system.odps2=true;
    
    ```

-   涉及INT类型，加上述set语句的时候是32位，不加的时候会被转换成BIGINT，是64位。
-   SDK 0.27.2-public版本及以上、客户端0.27.0版本及以上支持新数据类型。

MR类型任务目前暂时不支持操作新数据类型。

对setproject的详细说明请参见：[其他操作](cn.zh-CN/用户指南/常用命令/其他操作.md#)。

|类型|是否新增|常量定义|描述|
|:-|:---|:---|:-|
|TINYINT|是|1Y，-127Y|8位有符号整形，范围（-128）到127|
|SMALLINT|是|32767S， -100S|16位有符号整形， 范围（-32768）到 32767|
|INT|是|1000，-15645787（注释2）|32位有符号整形，范围（-2）31到231 - 1|
|BIGINT|否|100000000000L， -1L|64位有符号整形, 范围\(-2\)63 + 1到263 - 1|
|FLOAT|是|无|32位二进制浮点型|
|DOUBLE|否|3.1415926 1E+7|64位二进制浮点型|
|DECIMAL|否|3.5BD， 99999999999.9999999BD \( 注释1\)|10进制精确数字类型，整形部分范围\(-10\)36 + 1到1036 - 1, 小数部分精确到10-18|
|VARCHAR|是|无 \( 注释3\)|变长字符类型，n为长度，取值范围 1 到65535|
|STRING|否|“abc”，’bcd’，”alibaba” ‘inc’ \( 注释4 \)|字符串类型，目前长度限制为8M|
|BINARY|是|无|二进制数据类型，目前长度限制为 8M|
|DATETIME|否|DATETIME ‘2017-11-11 00:00:00’|日期时间类型，范围从0000年1月1日到9999年12月31日，精确到毫秒（注释5）|
|TIMESTAMP|是|TIMESTAMP ‘2017-11-11 00:00:00.123456789’|与时区相关的时间戳类型，范围从0000年1月1日到9999年12月31日 23.59:59.999999999, 精确到纳秒|
|BOOLEAN|否|TRUE，FALSE|boolean类型, 取值TRUE或FALSE|

上述的各种数据类型均可为NULL。

**说明：** 

-   注释1：insert一个常量到decimal字段时，注意常量的写法。如常量定义中的`3.5BD` ：

    ```
    insert into test_tb(a) values (3.5BD);
    ```

    其中a字段是decimal类型。

-   注释2：对于INT常量，如果超过INT取值范围，会转为BIGINT。如果超过BIGINT取值范围，会转为DOUBLE。

    在旧版MaxCompute中，因为历史原因，SQL脚本中的所有INT类型都被转换为BIGINT，如下所示：

    ```
    create table a_bigint_table(a int); -- 这里的int实际当作bigint处理
    select cast(id as int) from mytable; -- 这里的int实际当作bigint处理
    ```

    为了与MaxCompute原有模式兼容，MaxCompute2.0在未设定odps.sql.type.system.odps2为true的情况下，仍保留此转换，但会报告一个警告，提示INT被当作BIGINT处理了，如果您的脚本有此种情况，建议全部改写为BIGINT，避免混淆。

-   注释3：VARCHAR类型常量可通过STRING常量的隐式转换表示。
-   注释4：STRING常量支持连接，例如`abc` `xyz`会解析为`abcxyz`，不同部分可以写在不同行上。
-   注释5：目前查询显示的时间值不包含毫秒。Tunnel命令通过`-dfp`来指定时间格式，可以指定到毫秒显示，例如`tunnel upload -dfp 'yyyy-MM-dd HH:mm:ss.SSS'`，关于Tunnel命令的更多信息，请参考[Tunnel命令操作](cn.zh-CN/用户指南/数据上传下载/Tunnel命令操作.md#)。

## 复杂类型 {#section_r53_rbb_5db .section}

MaxCompute2.0支持的复杂类型如下表所示。

|类型|定义方法|构造方法|
|:-|:---|:---|
|ARRAY|array<int\>;array<struct< a:int, b:string\>\>|array\(1, 2, 3\); array\(array\(1, 2\); array\(3, 4\)\)|
|MAP|map<string, string \>;map<smallint, array<string\>\>|map\(“k1”, “v1”, “k2”, “v2”\);map\(1S, array\(‘a’, ‘b’\), 2S, array\(‘x’, ‘y\)\)|
|STRUCT|struct<x:int, y:int\>;struct< field1:bigint, field2:array<int\>, field3:map<int, int\>\>|named\_struct\(‘x’, 1, ‘y’, 2\);named\_struct\(‘field1’, 100L, ‘field2’, array\(1, 2\), ‘field3’, map\(1, 100, 2, 200\)|

**说明：** 

打开新类型`odps.sql.type.system.odps2`的主要影响：

-   隐式类型转换规则变化。

    可能的兼容性问题：新类型系统下某些隐式类型转换会被禁用， 包括string -\> bigint, string - \> datetime, double-\>bigint, decimal -\> double, decimal -\> bigint都是有精度损失或者报错的风险。这种情况可以通过cast函数做强制转换的方式来解决。

-   支持的操作，内置函数，UDF不一样。

    部分以新类型作为参数和返回值的操作和内置函数在不打开新类型时不可用；包括UDF，以新类型作为参数和返回值的UDF重载不可用。可能的兼容性问题：比如UDF包含bigint和int两个重载，旧类型下一定是bigint的重载，而新类型下可能会被解析到int的重载。

-   常量类型会变化。

    单独一个整形常量，如123，在旧类型下是bigint类型，在新类型下是int类型。可能的兼容性问题：类型是int导致后续一些操作调用到的函数原型不一致，包括落盘\(即写入磁盘\)后生成的新类型表会导致周边工具以及后续作业的行为改变。

-   bigint关键字的解析不一样。

    在旧类型系统下，int关键字被当做bigint来处理，而新类型系统，会当做真正的int处理。可能的兼容性问题：类型是int会导致后续一些操作调用到的函数原型不一致，包括落盘\(即写入磁盘\)后生成的新类型表会导致周边工具以及后续作业的行为改变。


